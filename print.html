<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Matthew Powers Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Index</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="usage/index.html"><strong aria-hidden="true">3.</strong> Usage</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="usage/loading-table.html"><strong aria-hidden="true">3.1.</strong> Loading a Delta Table</a></li><li class="chapter-item expanded "><a href="usage/examining-table.html"><strong aria-hidden="true">3.2.</strong> Examining a Delta Table</a></li><li class="chapter-item expanded "><a href="usage/querying-delta-tables.html"><strong aria-hidden="true">3.3.</strong> Querying a Delta Table</a></li><li class="chapter-item expanded "><a href="usage/managing-tables.html"><strong aria-hidden="true">3.4.</strong> Managing a Delta Table</a></li><li class="chapter-item expanded "><a href="usage/writing-delta-tables.html"><strong aria-hidden="true">3.5.</strong> Writing Delta Tables</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Matthew Powers Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="python-deltalake-package"><a class="header" href="#python-deltalake-package">Python deltalake package</a></h1>
<p>This is the documentation for the native Python implementation of
deltalake. It is based on the delta-rs Rust library and requires no
Spark or JVM dependencies. For the PySpark implementation, see
<a href="https://docs.delta.io/latest/api/python/index.html">delta-spark</a>
instead.</p>
<p>This module provides the capability to read, write, and manage <a href="https://delta.io/">Delta
Lake</a> tables from Python without Spark or Java. It
uses <a href="https://arrow.apache.org/">Apache Arrow</a> under the hood, so is
compatible with other Arrow-native or integrated libraries such as
<a href="https://pandas.pydata.org/">Pandas</a>, <a href="https://duckdb.org/">DuckDB</a>, and
<a href="https://www.pola.rs/">Polars</a>.</p>
<p>Note: This module is under active development and some features are
experimental. It is not yet as feature-complete as the PySpark
implementation of Delta Lake. If you encounter a bug, please let us know
in our <a href="https://github.com/delta-io/delta-rs/issues">GitHub repo</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="using-pip"><a class="header" href="#using-pip">Using Pip</a></h2>
<pre><code class="language-bash">pip install deltalake
</code></pre>
<p>NOTE: official binary wheels are linked against openssl statically for
remote objection store communication. Please file Github issue to
request for critical openssl upgrade.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<p>A <code>DeltaTable</code> represents the state of a
delta table at a particular version. This includes which files are
currently part of the table, the schema of the table, and other metadata
such as creation time.</p>
<pre><code class="language-python">&gt;&gt;&gt; from deltalake import DeltaTable
&gt;&gt;&gt; dt = DeltaTable(&quot;../rust/tests/data/delta-0.2.0&quot;)
&gt;&gt;&gt; dt.version()
3
&gt;&gt;&gt; dt.files()
['part-00000-cb6b150b-30b8-4662-ad28-ff32ddab96d2-c000.snappy.parquet', 
 'part-00000-7c2deba3-1994-4fb8-bc07-d46c948aa415-c000.snappy.parquet', 
 'part-00001-c373a5bd-85f0-4758-815e-7eb62007a15c-c000.snappy.parquet']
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loading-a-delta-table"><a class="header" href="#loading-a-delta-table">Loading a Delta Table</a></h1>
<p>To load the current version, use the constructor:</p>
<pre><code class="language-python">&gt;&gt;&gt; dt = DeltaTable(&quot;../rust/tests/data/delta-0.2.0&quot;)
</code></pre>
<p>Depending on your storage backend, you could use the <code>storage_options</code>
parameter to provide some configuration. Configuration is defined for
specific backends - <a href="https://docs.rs/object_store/latest/object_store/aws/enum.AmazonS3ConfigKey.html#variants">s3
options</a>,
<a href="https://docs.rs/object_store/latest/object_store/azure/enum.AzureConfigKey.html#variants">azure
options</a>,
<a href="https://docs.rs/object_store/latest/object_store/gcp/enum.GoogleConfigKey.html#variants">gcs
options</a>.</p>
<pre><code class="language-python">&gt;&gt;&gt; storage_options = {&quot;AWS_ACCESS_KEY_ID&quot;: &quot;THE_AWS_ACCESS_KEY_ID&quot;, &quot;AWS_SECRET_ACCESS_KEY&quot;:&quot;THE_AWS_SECRET_ACCESS_KEY&quot;}
&gt;&gt;&gt; dt = DeltaTable(&quot;../rust/tests/data/delta-0.2.0&quot;, storage_options=storage_options)
</code></pre>
<p>The configuration can also be provided via the environment, and the
basic service provider is derived from the URL being used. We try to
support many of the well-known formats to identify basic service
properties.</p>
<p><strong>S3</strong>:</p>
<blockquote>
<ul>
<li>s3://&lt;bucket&gt;/&lt;path&gt;</li>
<li>s3a://&lt;bucket&gt;/&lt;path&gt;</li>
</ul>
</blockquote>
<p><strong>Azure</strong>:</p>
<blockquote>
<ul>
<li>az://&lt;container&gt;/&lt;path&gt;</li>
<li>adl://&lt;container&gt;/&lt;path&gt;</li>
<li>abfs://&lt;container&gt;/&lt;path&gt;</li>
</ul>
</blockquote>
<p><strong>GCS</strong>:</p>
<blockquote>
<ul>
<li>gs://&lt;bucket&gt;/&lt;path&gt;</li>
</ul>
</blockquote>
<p>Alternatively, if you have a data catalog you can load it by reference
to a database and table name. Currently only AWS Glue is supported.</p>
<p>For AWS Glue catalog, use AWS environment variables to authenticate.</p>
<pre><code class="language-python">&gt;&gt;&gt; from deltalake import DeltaTable
&gt;&gt;&gt; from deltalake import DataCatalog
&gt;&gt;&gt; database_name = &quot;simple_database&quot;
&gt;&gt;&gt; table_name = &quot;simple_table&quot;
&gt;&gt;&gt; data_catalog = DataCatalog.AWS
&gt;&gt;&gt; dt = DeltaTable.from_data_catalog(data_catalog=data_catalog, database_name=database_name, table_name=table_name)
&gt;&gt;&gt; dt.to_pyarrow_table().to_pydict()
{'id': [5, 7, 9, 5, 6, 7, 8, 9]}
</code></pre>
<h2 id="custom-storage-backends"><a class="header" href="#custom-storage-backends">Custom Storage Backends</a></h2>
<p>While delta always needs its internal storage backend to work and be
properly configured, in order to manage the delta log, it may sometime
be advantageous - and is common practice in the arrow world - to
customize the storage interface used for reading the bulk data.</p>
<p><code>deltalake</code> will work with any storage compliant with <code>pyarrow.fs.FileSystem</code>, however the root of the filesystem has to be adjusted to point at the root of the Delta table. We can achieve this by wrapping the custom filesystem into a <code>pyarrow.fs.SubTreeFileSystem</code>.</p>
<pre><code class="language-python">import pyarrow.fs as fs
from deltalake import DeltaTable

path = &quot;&lt;path/to/table&gt;&quot;
filesystem = fs.SubTreeFileSystem(path, fs.LocalFileSystem())

dt = DeltaTable(path)
ds = dt.to_pyarrow_dataset(filesystem=filesystem)
</code></pre>
<p>When using the pyarrow factory method for file systems, the normalized
path is provided on creation. In case of S3 this would look something
like:</p>
<pre><code class="language-python">import pyarrow.fs as fs
from deltalake import DeltaTable

table_uri = &quot;s3://&lt;bucket&gt;/&lt;path&gt;&quot;
raw_fs, normalized_path = fs.FileSystem.from_uri(table_uri)
filesystem = fs.SubTreeFileSystem(normalized_path, raw_fs)

dt = DeltaTable(table_uri)
ds = dt.to_pyarrow_dataset(filesystem=filesystem)
</code></pre>
<h2 id="time-travel"><a class="header" href="#time-travel">Time Travel</a></h2>
<p>To load previous table states, you can provide the version number you
wish to load:</p>
<pre><code class="language-python">&gt;&gt;&gt; dt = DeltaTable(&quot;../rust/tests/data/simple_table&quot;, version=2)
</code></pre>
<p>Once you've loaded a table, you can also change versions using either a
version number or datetime string:</p>
<pre><code class="language-python">&gt;&gt;&gt; dt.load_version(1)
&gt;&gt;&gt; dt.load_with_datetime(&quot;2021-11-04 00:05:23.283+00:00&quot;)
</code></pre>
<p>::: warning
::: title
Warning
:::</p>
<p>Previous table versions may not exist if they have been vacuumed, in
which case an exception will be thrown. See <a href="usage/loading-table.html#vacuuming-tables">Vacuuming
tables</a> for more information.
:::</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examining-a-table"><a class="header" href="#examining-a-table">Examining a Table</a></h1>
<h2 id="metadata"><a class="header" href="#metadata">Metadata</a></h2>
<p>The delta log maintains basic metadata about a table, including:</p>
<ul>
<li>A unique <code>id</code></li>
<li>A <code>name</code>, if provided</li>
<li>A <code>description</code>, if provided</li>
<li>The list of <code>partitionColumns</code>.</li>
<li>The <code>created_time</code> of the table</li>
<li>A map of table <code>configuration</code>. This includes fields such as
<code>delta.appendOnly</code>, which if <code>true</code> indicates the table is not meant
to have data deleted from it.</li>
</ul>
<p>Get metadata from a table with the
<code>DeltaTable.metadata</code> method:</p>
<pre><code class="language-python">&gt;&gt;&gt; from deltalake import DeltaTable
&gt;&gt;&gt; dt = DeltaTable(&quot;../rust/tests/data/simple_table&quot;)
&gt;&gt;&gt; dt.metadata()
Metadata(id: 5fba94ed-9794-4965-ba6e-6ee3c0d22af9, name: None, description: None, partitionColumns: [], created_time: 1587968585495, configuration={})
</code></pre>
<h2 id="schema"><a class="header" href="#schema">Schema</a></h2>
<p>The schema for the table is also saved in the transaction log. It can
either be retrieved in the Delta Lake form as
<code>deltalake.schema.Schema</code> or as a
PyArrow schema. The first allows you to introspect any column-level
metadata stored in the schema, while the latter represents the schema
the table will be loaded into.</p>
<p>Use <code>DeltaTable.schema</code> to retrieve the delta lake schema:</p>
<pre><code class="language-python">&gt;&gt;&gt; from deltalake import DeltaTable
&gt;&gt;&gt; dt = DeltaTable(&quot;../rust/tests/data/simple_table&quot;)
&gt;&gt;&gt; dt.schema()
Schema([Field(id, PrimitiveType(&quot;long&quot;), nullable=True)])
</code></pre>
<p>These schemas have a JSON representation that can be retrieved. To
reconstruct from json, use
<code>deltalake.schema.Schema.from_json()</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; dt.schema().json()
'{&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[{&quot;name&quot;:&quot;id&quot;,&quot;type&quot;:&quot;long&quot;,&quot;nullable&quot;:true,&quot;metadata&quot;:{}}]}'
</code></pre>
<p>Use <code>deltalake.schema.Schema.to_pyarrow()</code> to retrieve the PyArrow schema:</p>
<pre><code class="language-python">&gt;&gt;&gt; dt.schema().to_pyarrow()
id: int64
</code></pre>
<h2 id="history"><a class="header" href="#history">History</a></h2>
<p>Depending on what system wrote the table, the delta table may have
provenance information describing what operations were performed on the
table, when, and by whom. This information is retained for 30 days by
default, unless otherwise specified by the table configuration
<code>delta.logRetentionDuration</code>.</p>
<p>::: note
::: title
Note
:::</p>
<p>This information is not written by all writers and different writers may
use different schemas to encode the actions. For Spark's format, see:
<a href="https://docs.delta.io/latest/delta-utility.html#history-schema">https://docs.delta.io/latest/delta-utility.html#history-schema</a>
:::</p>
<p>To view the available history, use <code>DeltaTable.history</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; from deltalake import DeltaTable
&gt;&gt;&gt; dt = DeltaTable(&quot;../rust/tests/data/simple_table&quot;)
&gt;&gt;&gt; dt.history()
[{'timestamp': 1587968626537, 'operation': 'DELETE', 'operationParameters': {'predicate': '[&quot;((`id` % CAST(2 AS BIGINT)) = CAST(0 AS BIGINT))&quot;]'}, 'readVersion': 3, 'isBlindAppend': False},
 {'timestamp': 1587968614187, 'operation': 'UPDATE', 'operationParameters': {'predicate': '((id#697L % cast(2 as bigint)) = cast(0 as bigint))'}, 'readVersion': 2, 'isBlindAppend': False},
 {'timestamp': 1587968604143, 'operation': 'WRITE', 'operationParameters': {'mode': 'Overwrite', 'partitionBy': '[]'}, 'readVersion': 1, 'isBlindAppend': False},
 {'timestamp': 1587968596254, 'operation': 'MERGE', 'operationParameters': {'predicate': '(oldData.`id` = newData.`id`)'}, 'readVersion': 0, 'isBlindAppend': False},
 {'timestamp': 1587968586154, 'operation': 'WRITE', 'operationParameters': {'mode': 'ErrorIfExists', 'partitionBy': '[]'}, 'isBlindAppend': True}]
</code></pre>
<h2 id="current-add-actions"><a class="header" href="#current-add-actions">Current Add Actions</a></h2>
<p>The active state for a delta table is determined by the Add actions,
which provide the list of files that are part of the table and metadata
about them, such as creation time, size, and statistics. You can get a
data frame of the add actions data using <code>DeltaTable.get_add_actions</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; from deltalake import DeltaTable
&gt;&gt;&gt; dt = DeltaTable(&quot;../rust/tests/data/delta-0.8.0&quot;)
&gt;&gt;&gt; dt.get_add_actions(flatten=True).to_pandas()
                                                    path  size_bytes   modification_time  data_change  num_records  null_count.value  min.value  max.value
0  part-00000-c9b90f86-73e6-46c8-93ba-ff6bfaf892a...         440 2021-03-06 15:16:07         True            2                 0          0          2
1  part-00000-04ec9591-0b73-459e-8d18-ba5711d6cbe...         440 2021-03-06 15:16:16         True            2                 0          2          4
</code></pre>
<p>This works even with past versions of the table:</p>
<pre><code class="language-python">&gt;&gt;&gt; dt = DeltaTable(&quot;../rust/tests/data/delta-0.8.0&quot;, version=0)
&gt;&gt;&gt; dt.get_add_actions(flatten=True).to_pandas()
                                                path  size_bytes   modification_time  data_change  num_records  null_count.value  min.value  max.value
0  part-00000-c9b90f86-73e6-46c8-93ba-ff6bfaf892a...         440 2021-03-06 15:16:07         True            2                 0          0          2
1  part-00001-911a94a2-43f6-4acb-8620-5e68c265498...         445 2021-03-06 15:16:07         True            3                 0          2          4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="querying-delta-tables"><a class="header" href="#querying-delta-tables">Querying Delta Tables</a></h1>
<p>Delta tables can be queried in several ways. By loading as Arrow data or
an Arrow dataset, they can be used by compatible engines such as Pandas
and DuckDB. By passing on the list of files, they can be loaded into
other engines such as Dask.</p>
<p>Delta tables are often larger than can fit into memory on a single
computer, so this module provides ways to read only the parts of the
data you need. Partition filters allow you to skip reading files that
are part of irrelevant partitions. Only loading the columns required
also saves memory. Finally, some methods allow reading tables
batch-by-batch, allowing you to process the whole table while only
having a portion loaded at any given time.</p>
<p>To load into Pandas or a PyArrow table use the <code>DeltaTable.to_pandas</code> and <code>DeltaTable.to_pyarrow_table</code> methods, respectively. Both of these support filtering partitions and selecting particular columns.</p>
<pre><code class="language-python">&gt;&gt;&gt; from deltalake import DeltaTable
&gt;&gt;&gt; dt = DeltaTable(&quot;../rust/tests/data/delta-0.8.0-partitioned&quot;)
&gt;&gt;&gt; dt.schema().to_pyarrow()
value: string
year: string
month: string
day: string
&gt;&gt;&gt; dt.to_pandas(partitions=[(&quot;year&quot;, &quot;=&quot;, &quot;2021&quot;)], columns=[&quot;value&quot;])
      value
0     6
1     7
2     5
3     4
&gt;&gt;&gt; dt.to_pyarrow_table(partitions=[(&quot;year&quot;, &quot;=&quot;, &quot;2021&quot;)], columns=[&quot;value&quot;])
pyarrow.Table
value: string
</code></pre>
<p>Converting to a PyArrow Dataset allows you to filter on columns other
than partition columns and load the result as a stream of batches rather
than a single table. Convert to a dataset using
<code>DeltaTable.to_pyarrow_dataset</code>. Filters
applied to datasets will use the partition values and file statistics
from the Delta transaction log and push down any other filters to the
scanning operation.</p>
<pre><code class="language-python">&gt;&gt;&gt; import pyarrow.dataset as ds
&gt;&gt;&gt; dataset = dt.to_pyarrow_dataset()
&gt;&gt;&gt; condition = (ds.field(&quot;year&quot;) == &quot;2021&quot;) &amp; (ds.field(&quot;value&quot;) &gt; &quot;4&quot;)
&gt;&gt;&gt; dataset.to_table(filter=condition, columns=[&quot;value&quot;]).to_pandas()
  value
0     6
1     7
2     5
&gt;&gt;&gt; batch_iter = dataset.to_batches(filter=condition, columns=[&quot;value&quot;], batch_size=2)
&gt;&gt;&gt; for batch in batch_iter: print(batch.to_pandas())
  value
0     6
1     7
  value
0     5
</code></pre>
<p>PyArrow datasets may also be passed to compatible query engines, such as
<a href="https://duckdb.org/docs/api/python">DuckDB</a>.</p>
<pre><code class="language-python">&gt;&gt;&gt; import duckdb
&gt;&gt;&gt; ex_data = duckdb.arrow(dataset)
&gt;&gt;&gt; ex_data.filter(&quot;year = 2021 and value &gt; 4&quot;).project(&quot;value&quot;)
---------------------
-- Expression Tree --
---------------------
Projection [value]
  Filter [year=2021 AND value&gt;4]
    arrow_scan(140409099470144, 4828104688, 1000000)

---------------------
-- Result Columns  --
---------------------
- value (VARCHAR)

---------------------
-- Result Preview  --
---------------------
value
VARCHAR
[ Rows: 3]
6
7
5
</code></pre>
<p>Finally, you can always pass the list of file paths to an engine. For
example, you can pass them to <code>dask.dataframe.read_parquet</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; import dask.dataframe as dd
&gt;&gt;&gt; df = dd.read_parquet(dt.file_uris())
&gt;&gt;&gt; df
Dask DataFrame Structure:
                value             year            month              day
npartitions=6                                                           
               object  category[known]  category[known]  category[known]
                  ...              ...              ...              ...
...               ...              ...              ...              ...
                  ...              ...              ...              ...
                  ...              ...              ...              ...
Dask Name: read-parquet, 6 tasks
&gt;&gt;&gt; df.compute()
  value  year month day
0     1  2020     1   1
0     2  2020     2   3
0     3  2020     2   5
0     4  2021     4   5
0     5  2021    12   4
0     6  2021    12  20
1     7  2021    12  20
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-delta-tables"><a class="header" href="#managing-delta-tables">Managing Delta Tables</a></h1>
<h2 id="vacuuming-tables"><a class="header" href="#vacuuming-tables">Vacuuming tables</a></h2>
<p>Vacuuming a table will delete any files that have been marked for
deletion. This may make some past versions of a table invalid, so this
can break time travel. However, it will save storage space. Vacuum will
retain files in a certain window, by default one week, so time travel
will still work in shorter ranges.</p>
<p>Delta tables usually don't delete old files automatically, so vacuuming
regularly is considered good practice, unless the table is only appended
to.</p>
<p>Use <code>DeltaTable.vacuum</code> to perform the vacuum operation. Note that to prevent accidental deletion, the function performs a dry-run by default: it will only list the files to be deleted. Pass <code>dry_run=False</code> to actually delete files.</p>
<pre><code class="language-python">&gt;&gt;&gt; dt = DeltaTable(&quot;../rust/tests/data/simple_table&quot;)
&gt;&gt;&gt; dt.vacuum()
['../rust/tests/data/simple_table/part-00006-46f2ff20-eb5d-4dda-8498-7bfb2940713b-c000.snappy.parquet', 
 '../rust/tests/data/simple_table/part-00190-8ac0ae67-fb1d-461d-a3d3-8dc112766ff5-c000.snappy.parquet', 
 '../rust/tests/data/simple_table/part-00164-bf40481c-4afd-4c02-befa-90f056c2d77a-c000.snappy.parquet',
 ...]
&gt;&gt;&gt; dt.vacuum(dry_run=False) # Don't run this unless you are sure!
</code></pre>
<h2 id="optimizing-tables"><a class="header" href="#optimizing-tables">Optimizing tables</a></h2>
<p>Optimizing tables is not currently supported.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-delta-tables"><a class="header" href="#writing-delta-tables">Writing Delta Tables</a></h1>
<p>For overwrites and appends, use <code>write_deltalake</code>. If the table does not already exist, it will be created.
The <code>data</code> parameter will accept a Pandas DataFrame, a PyArrow Table, or
an iterator of PyArrow Record Batches.</p>
<pre><code class="language-python">&gt;&gt;&gt; from deltalake.writer import write_deltalake
&gt;&gt;&gt; df = pd.DataFrame({'x': [1, 2, 3]})
&gt;&gt;&gt; write_deltalake('path/to/table', df)
</code></pre>
<p>Note: <code>write_deltalake</code> accepts a Pandas DataFrame, but will convert it to a Arrow table before writing. See caveats in <code>pyarrow:python/pandas</code>.</p>
<p>By default, writes create a new table and error if it already exists.
This is controlled by the <code>mode</code> parameter, which mirrors the behavior
of Spark's <code>pyspark.sql.DataFrameWriter.saveAsTable</code> DataFrame method. To overwrite pass in <code>mode='overwrite'</code> and to append pass in <code>mode='append'</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; write_deltalake('path/to/table', df, mode='overwrite')
&gt;&gt;&gt; write_deltalake('path/to/table', df, mode='append')
</code></pre>
<p><code>write_deltalake</code> will raise <code>ValueError</code> if the schema of the data
passed to it differs from the existing table's schema. If you wish to
alter the schema as part of an overwrite pass in <code>overwrite_schema=True</code>.</p>
<h2 id="overwriting-a-partition"><a class="header" href="#overwriting-a-partition">Overwriting a partition</a></h2>
<p>You can overwrite a specific partition by using <code>mode=&quot;overwrite&quot;</code>
together with <code>partition_filters</code>. This will remove all files within the
matching partition and insert your data as new files. This can only be
done on one partition at a time. All of the input data must belong to
that partition or else the method will raise an error.</p>
<pre><code class="language-python">&gt;&gt;&gt; from deltalake.writer import write_deltalake
&gt;&gt;&gt; df = pd.DataFrame({'x': [1, 2, 3], 'y': ['a', 'a', 'b']})
&gt;&gt;&gt; write_deltalake('path/to/table', df, partition_by=['y'])

&gt;&gt;&gt; table = DeltaTable('path/to/table')
&gt;&gt;&gt; df2 = pd.DataFrame({'x': [100], 'y': ['b']})
&gt;&gt;&gt; write_deltalake(table, df2, partition_filters=[('y', '=', 'b')], mode=&quot;overwrite&quot;)

&gt;&gt;&gt; table.to_pandas()
     x  y
0    1  a
1    2  a
2  100  b
</code></pre>
<p>This method could also be used to insert a new partition if one doesn't
already exist, making this operation idempotent.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
